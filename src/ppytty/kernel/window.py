# ----------------------------------------------------------------------------
# ppytty
# ----------------------------------------------------------------------------
# Copyright (c) Tiago Montes.
# See LICENSE for details.
# ----------------------------------------------------------------------------

import functools

import pyte



class _SelfBlessingsTerminal(object):

    # This class is necessary due to a Python curses limitation: read on.
    #
    # Window objects have a render method that produces a byte-string
    # containing all the character data and formatting/cursor movement escape
    # codes representing the current Window contents. To do that, Window.render
    # needs to know the appropriate escape codes for the destination terminal.
    #
    # Blessings (https://github.com/erikrose/blessings) is a Python library
    # that helps with that: it produces the proper escape sequences for generic
    # terminal based output including formatting, cursor movement and more. It
    # uses curses' setupterm, tigetstr, tparm and friends to obtain the proper
    # escape codes for a given terminal, as long as it is present in the
    # system's terminfo database.
    #
    # With that, the generic actual output producing code would be:
    #
    # >>> w = Window(...)
    # >>> bt = blessings.Terminal(kind=os.environ['TERM'])
    # >>> data = w.render(bt)
    # >>> sys.stdout.write(data.encode(...))
    #
    # There is one more thing, though: Windows can be rendered onto other
    # Windows. Internally they wrap a pyte (https://github.com/selectel/pyte)
    # Screen and ByteStream which, collectivelly, implement a 'linux' terminal,
    # per the docs, but actually seems to support 'xterm-256color'. To render
    # a Window onto another Window the code would be:
    #
    # >>> parent = Window(...)
    # >>> child = Window(...)
    # >>> bt_child = blessings.Terminal(kind='linux')
    # >>> data = child.render(bt_child)
    # >>> parent.feed(data)
    #
    # And the Window to "real" terminal rendering, again:
    #
    # >>> bt_parent = blessings.Terminal(kind=os.environ['TERM'])
    # >>> data = parent.render(bt_parent)
    # >>> sys.stdout.write(data.encode(...))
    #
    # This would all be fine EXCEPT, like stated in the first comment line, it
    # does not work due to a Python curses limitation (which Blessings uses).
    # Here's a short demo, getting the "set forground color" escape sequence:
    #
    # >>> curses.setupterm('xterm-256color')
    # >>> curses.tparm(curses.tigetstr('setaf'), 31)
    # b'\x1b[38;5;31m'
    #
    # It first calls setupterm, then tigetstr/tparm to get that terminal's
    # escape sequences. The Python curses implementation has a LIMITATION in
    # that it discards subsequent calls to setupterm, preventing a program
    # from acessing the terminfo database for multiple terminal types.
    # (see https://bugs.python.org/issue7567#msg113216)

    # These were generated by hand with a Blessings Terminal instance with
    # kind='xterm-256color', which pyte's Screen/ByteStream handle nicely.

    def __init__(self, width, height):

        self.width = width
        self.height = height


    hide_cursor = '\x1b[?25l'
    normal_cursor = '\x1b[?12l\x1b[?25h'

    normal = '\x1b(B\x1b[m'
    bold = '\x1b[1m'
    reverse = '\x1b[7m'

    @staticmethod
    def move(line, column):
        return f'\x1b[{line+1};{column+1}H'

    @staticmethod
    def color(fg_color):
        if fg_color < 8:
            return f'\x1b[{30+fg_color}m'
        elif fg_color < 16:
            return f'\x1b[{82+fg_color}m'
        elif fg_color < 256:
            return f'\x1b[38;5;{fg_color}m'
        else:
            raise ValueError(f'invalid fg_color: {fg_color}')

    @staticmethod
    def on_color(bg_color):
        if bg_color < 8:
            return f'\x1b[{40+bg_color}m'
        elif bg_color < 16:
            return f'\x1b[{92+bg_color}m'
        elif bg_color < 256:
            return f'\x1b[48;5;{bg_color}m'
        else:
            raise ValueError(f'invalid bg_color: {bg_color}')



class Window(object):

    def __init__(self, parent, left, top, width, height, bg=None, no_cursor=True):

        # We don't really care about the parent itself; all we need is its `bt`
        # attribute so that we can:
        # - Get the parent's width/height.
        # - Produce the correct escape sequences when rendering.
        self._parent_bt = parent.bt

        self._left = left
        self._top = top
        self._width = width
        self._height = height
        self._bg = bg

        self._screen = pyte.Screen(width, height)
        self._stream = pyte.ByteStream(self._screen)

        self._screen.cursor.hidden = no_cursor

        # My public `bt` so others can:
        # - Get my width/height.
        # - Produce the correct escape sequences to be used in self.feed().
        self.bt = _SelfBlessingsTerminal(width, height)


    def __repr__(self):

        geometry = f'{self._width}x{self._height}'
        location = f'{self._left},{self._top}'
        return f'<Window {geometry}@{location} {hex(id(self))}>'


    @property
    def parent_width(self):

        return self._parent_bt.width


    @property
    def parent_height(self):

        return self._parent_bt.height


    def overlaps(self, window):

        a_min_x = self._left
        a_max_x = a_min_x + self._width - 1
        a_min_y = self._top
        a_max_y = a_min_y + self._height - 1
        b_min_x = window._left
        b_max_x = b_min_x + window._width - 1
        b_min_y = window._top
        b_max_y = b_min_y + window._height - 1
        horizontal = (a_min_x <= b_max_x) and (a_max_x >= b_min_x)
        vertical = (a_min_y <= b_max_y) and (a_max_y >= b_min_y)
        return horizontal and vertical


    def clear(self, how=2):

        self._screen.erase_in_display(how)
        self._screen.cursor_position()


    def print(self, text, x=None, y=None, fg=None, bg=None):

        attrs = []
        if fg is not None:
            attrs.extend((38, 5, fg))
        if bg is not None:
            attrs.extend((48, 5, bg))
        if attrs:
            self._screen.select_graphic_rendition(*attrs)

        if x is not None and y is not None:
            self._screen.cursor_position(y+1, x+1)

        self._stream.feed(text.encode('utf8'))

        if attrs:
            self._screen.select_graphic_rendition(0)


    def feed(self, data):

        self._stream.feed(data)


    def render(self, full=False, encoding='utf8'):

        screen = self._screen
        screen_cursor = screen.cursor
        screen_buffer = screen.buffer
        screen_dirty = screen.dirty
        left = self._left
        top = self._top
        width = self._width
        height = self._height
        window_bg = self._bg

        bt = self._parent_bt
        bt_move = bt.move
        self_char_format = self._char_format

        payload = []
        payload_append = payload.append

        prev_char_format = ''
        line_numbers = range(height) if full else screen_dirty

        if line_numbers and not screen_cursor.hidden:
            payload_append(bt.hide_cursor)

        for line_no in line_numbers:
            line_data = screen_buffer[line_no]
            payload_append(bt_move(top+line_no, left))
            for column_no in range(width):
                char_data, fg, bg, bold, _, _, _, reverse = line_data[column_no]
                default_bg = window_bg
                if hasattr(window_bg, '__getitem__'):
                    default_bg = window_bg[line_no][column_no]
                char_format = self_char_format(bt, fg, bg, bold, reverse, default_bg)
                if char_format != prev_char_format:
                    payload_append(char_format)
                    prev_char_format = char_format
                payload_append(char_data)

        if line_numbers:
            payload_append(bt.normal)
            payload_append(bt_move(top+screen_cursor.y, left+screen_cursor.x))
            if not screen_cursor.hidden:
                payload_append(bt.normal_cursor)
        screen_dirty.clear()
        return ''.join(payload).encode(encoding)


    # These will be used when rendering the pyte.Screen to a blessings generated
    # byte-string.

    _COLORS = {}
    for k, v in pyte.graphics.FG_ANSI.items():
        _COLORS[v] = k-30
    del _COLORS['default']
    for i, v in enumerate(pyte.graphics.FG_BG_256):
        _COLORS[v] = i


    @functools.lru_cache(maxsize=None)
    def _char_format(self, bt, fg, bg, bold, reverse, default_bg):

        colors = self._COLORS
        parts = [bt.normal]
        parts_append = parts.append
        if bold:
            parts_append(bt.bold)
        if reverse:
            parts_append(bt.reverse)
        fg_idx = colors.get(fg)
        if fg_idx is not None:
            parts_append(bt.color(fg_idx))
        bg_idx = colors.get(bg, default_bg)
        if bg_idx is not None:
            parts_append(bt.on_color(bg_idx))
        return ''.join(parts)


# ----------------------------------------------------------------------------
